# 클래스패스 : 클래스 경로
 - 클래스 찾는 경로 개발자가 직접 지정 가능
 - 클래스 패스를 하는 이유?
   - 메인 메소드를 그대로 둔 상태에서 클래스를 다른 하위폴더에 옮겨도 실행은 가능하지만 에러발생! 그렇기 때문에 이런 경우를 대비해 클래스패스로 경로를 직접 지정해준다
```java
                    //↓현재디렉토리
명령프롬포터(cmd) :  c:\User\AI> javac Hello.java
 
변경방법 : c:\User\AI> set classpath=.;변경할 경로
                               /*   ↑ . 은(cmd가 실행중인 상황에서 현재 디렉토리를 의미)
                               여전히 나는 이 경로에서 찾겟다고 명시해두는것 */
```

# 패키지 
: 같은 클래스명은 공간과 인스턴스 생성에서 충돌을 부르고 오류를 발생시김 따라서 오류 방지를 위해 1. 공간: directory를 변경 2. 인스턴스 경로를 지시해서 생성한다 
```java
//패키지 선언이란 같은 클래스명을 유일한 클래스(다른 클래스)로 인식하게 만들어 주는 것

패키지 선언방식
- pakage 인터넷도메인이름역순.클래스의 정의한주체or팀의이름
ex) www.sbns.com -> pakage com.sbns.lsb

// 패키지선언을 함과 동시에 포함되어있는 클래스는 com>sbns>lsb 에 들어있어야 인스턴스 생성이 가능
```

# 정보은닉 : 클래스 외부에서의 접근을 막는 것
: 접근을 제한없이 허용하게 되면 논리적 오류가 발생하기도 함(ex.클래스가 다른데 각 클래스 함수의 네임이 같다던지 하는)

 ## <클래스 외부허용범위>

| pubilc | 외부접근 다 가능 / 어디서나 인스턴스 생성 가능 | 소스파일명 = 클래스명(반드시)| 
|:----------|:----------:|----------:|
| protected | 동일패키지, 상속 받은 클래스 접근 가능 | 
| default | 동일 패키지만 접근가능 | 
| private | 클래스 내부에서만 접근가능 |

<br>

- public : 하나의 클래스 안에 하나만 가능 why? 클래스와 소스파일의 '이름'이 같아야되기 때문에
- default : 패키지 선언을 해주지 않은 클래스들끼리 하나의 패키지로 구성하는 것
```java
class ZZZ {  }  // 클래스 타입이 아무것도 선언되지 않음 '디폴트 패키지'
